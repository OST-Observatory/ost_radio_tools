#!/usr/bin/env python3
"""
plot_amplitude_sum_vs_time.py

This script visualizes amplitude sum over time from data generated by calculate_amplitude_sum.
It reads amplitude data from a .dat file and creates a plot showing how the amplitude sum
varies over time.

Usage:
    ./plot_amplitude_sum_vs_time.py <input_file> [options]

Arguments:
    input_file: Path to the input file containing time and amplitude data

Options:
    --output, -o: Output file for the plot (default: amplitude_sum_plot_<input>.png)
    --sampling-rate, -s: Sampling rate in Hz (default: extracted from filename)
    --center-frequency, -f: Center frequency (default: extracted from filename)
    --start-time, -t: Start time in format YYYYMMDD_HHMMSS (default: extracted from filename)
    --linear, -l: Display amplitude in linear scale instead of dB
    --fit-gaussian, -g: Fit and plot a Gaussian curve to the data

Features:
    - Plots amplitude sum values over time
    - Time display in either datetime or seconds
    - Amplitude display in linear or dB scale
    - Optional Gaussian curve fitting with FWHM calculation
    - Center frequency and start time in title if available
    - Grid for better readability
    - High-resolution output (300 DPI)

Example:
    ./plot_amplitude_sum_vs_time.py amplitude_gqrx_20250404_084805_1419390700_1800000_fc_sun.dat --linear
"""

import sys
import numpy as np
import matplotlib.pyplot as plt
from pathlib import Path
from typing import Tuple, Optional
from datetime import datetime, timedelta
import argparse
import os
import re
from scipy.optimize import curve_fit


def extract_start_time(filename: str) -> Optional[datetime]:
    """Extract start time from filename.
    
    Args:
        filename: The name of the input file, which should contain the start time
                 in the format: amplitude_gqrx_'start_date'_'start_time'_'frequency'_samples-per-block'_fc_'object'.raw
    
    Returns:
        datetime: The start time as a datetime object, or None if extraction fails.
    """
    try:
        # Get the base filename without path and extension
        base_name = Path(filename).stem
        # Split by underscore and get the date and time parts
        parts = base_name.split('_')
        if len(parts) >= 3:
            date_str = parts[2]  # Format: YYYYMMDD
            time_str = parts[3]  # Format: HHMMSS
            datetime_str = f"{date_str} {time_str}"
            return datetime.strptime(datetime_str, "%Y%m%d %H%M%S")
        else:
            print(f"Warning: Could not extract start time from filename")
            return None
    except (ValueError, IndexError):
        print("Warning: Could not extract start time from filename")
        return None

def parse_filename(filename: str) -> Tuple[Optional[int], Optional[str], Optional[datetime]]:
    """Extract sampling rate, center frequency, and start time from filename.
    
    Args:
        filename: The name of the input file, which should follow the format:
                 gqrx_YYYYMMDD_HHMMSS_FREQUENCY_SAMPLINGRATE_fc_OBJECT.raw
    
    Returns:
        Tuple containing:
        - sampling_rate: The sampling rate in Hz, or None if not found
        - center_frequency: The center frequency in Hz, or None if not found
        - start_time: The start time as a datetime object, or None if not found
    """
    # Extract sampling rate and center frequency from filename
    # Example: gqrx_20250404_113633_1419390700_1800000_fc_Milky_Way.raw
    match = re.search(r'_(\d+)_fc_', filename)
    if match:
        sampling_rate = int(match.group(1))
    else:
        sampling_rate = None

    # Extract center frequency (the number before the sampling rate)
    match = re.search(r'_(\d+)_\d+_fc_', filename)
    if match:
        center_frequency = match.group(1)
    else:
        center_frequency = None

    # Extract start time from filename
    # Format: gqrx_YYYYMMDD_HHMMSS_...
    match = re.search(r'gqrx_(\d{8})_(\d{6})', filename)
    if match:
        date_str = match.group(1)
        time_str = match.group(2)
        try:
            start_time = datetime.strptime(f"{date_str} {time_str}", "%Y%m%d %H%M%S")
        except ValueError:
            start_time = None
    else:
        start_time = None

    return sampling_rate, center_frequency, start_time

def gaussian(x, amplitude, mean, sigma):
    """Gaussian function for fitting"""
    return amplitude * np.exp(-(x - mean)**2 / (2 * sigma**2))

def fit_gaussian(time, amplitude):
    """Fit a Gaussian curve to the amplitude data"""
    # Initial guess for parameters [amplitude, mean, sigma]
    p0 = [np.max(amplitude), np.mean(time), np.std(time)]
    
    # Fit the Gaussian
    popt, pcov = curve_fit(gaussian, time, amplitude, p0=p0)
    
    # Calculate FWHM (Full Width at Half Maximum)
    fwhm = 2.355 * popt[2]  # FWHM = 2.355 * sigma
    
    return popt, pcov, fwhm

def plot_amplitude_vs_time(
    input_file: str,
    output_file: Optional[str] = None,
    sampling_rate: Optional[int] = None,
    center_frequency: Optional[str] = None,
    start_time: Optional[datetime] = None,
    linear: bool = False,
    fit_gaussian_curve: bool = False
) -> None:
    """Plot amplitude vs time from processed I/Q data.
    The function will:
    1. Load the amplitude data from the input file
    2. Convert amplitude to dB if linear=False
    3. Create a plot with time on x-axis and amplitude on y-axis
    4. Add appropriate labels, title, and grid
    5. Save the plot to the output file
    
    Args:
        input_file: Path to the input file containing time and amplitude data
        output_file: Path for the output plot file (default: amplitude_plot_<input>.png)
        sampling_rate: Sampling rate in Hz (default: extracted from filename)
        center_frequency: Center frequency in Hz (default: extracted from filename)
        start_time: Start time as datetime object (default: extracted from filename)
        linear: If True, display amplitude in linear scale instead of dB
        fit_gaussian_curve: If True, fit and plot a Gaussian curve to the data
    """
    # Load data
    data = np.loadtxt(input_file)
    time = data[:, 0]
    amplitude = data[:, 1]

    # If sampling_rate not provided, try to get it from filename
    if sampling_rate is None:
        sampling_rate, _, _ = parse_filename(input_file)
        if sampling_rate is None:
            print("Warning: Could not determine sampling rate from filename. Using default value of 1 Hz.")
            sampling_rate = 1

    # If start_time not provided, try to get it from filename
    if start_time is None:
        _, _, start_time = parse_filename(input_file)

    # Create plot
    plt.figure(figsize=(12, 6))

    # Convert amplitude to dB if linear is False
    if not linear:
        amplitude = 20 * np.log10(amplitude)
    
    # Plot the data
    if start_time:
        # Convert time indices to datetime objects
        time_dt = [start_time + timedelta(seconds=int(t)) for t in time]
        plt.plot(time_dt, amplitude, 'b.', label='Measured Data', alpha=0.5)
        plt.xlabel('Time')
        plt.gcf().autofmt_xdate()  # Rotate and align the tick labels
    else:
        plt.plot(time, amplitude, 'b.', label='Measured Data', alpha=0.5)
        plt.xlabel('Time (s)')
    
    # Fit and plot Gaussian if requested
    if fit_gaussian_curve:
        popt, pcov, fwhm = fit_gaussian(time, amplitude)
        
        # Plot fitted Gaussian
        x_fit = np.linspace(min(time), max(time), 1000)
        y_fit = gaussian(x_fit, *popt)
        
        if start_time:
            x_fit_dt = [start_time + timedelta(seconds=int(t)) for t in x_fit]
            plt.plot(x_fit_dt, y_fit, 'r-', label='Gaussian Fit')
            # Add FWHM lines
            fwhm_time1 = start_time + timedelta(seconds=int(popt[1] - fwhm/2))
            fwhm_time2 = start_time + timedelta(seconds=int(popt[1] + fwhm/2))
            plt.axvline(x=fwhm_time1, color='g', linestyle='--', alpha=0.5)
            plt.axvline(x=fwhm_time2, color='g', linestyle='--', alpha=0.5)
        else:
            plt.plot(x_fit, y_fit, 'r-', label='Gaussian Fit')
            plt.axvline(x=popt[1] - fwhm/2, color='g', linestyle='--', alpha=0.5)
            plt.axvline(x=popt[1] + fwhm/2, color='g', linestyle='--', alpha=0.5)
        
        # Add FWHM to title
        title_fwhm = f'\nFWHM = {fwhm:.2f} seconds'
    else:
        title_fwhm = ''
    
    plt.ylabel('Amplitude' if linear else 'Amplitude (dB)')
    
    # Add center frequency and start time to title if available
    if center_frequency is None:
        _, center_frequency, _ = parse_filename(input_file)
    
    if center_frequency and not start_time:
        plt.title(f'Amplitude vs Time (Center Frequency: {center_frequency}){title_fwhm}')
    elif start_time and not center_frequency:
        plt.title(f'Amplitude vs Time (Start Time: {start_time}){title_fwhm}')
    elif center_frequency and start_time:
        plt.title(f'Amplitude vs Time (Center Frequency: {center_frequency}, Start Time: {start_time}){title_fwhm}')
    else:
        plt.title(f'Amplitude vs Time{title_fwhm}')

    plt.legend()
    plt.grid(True)

    # Save plot
    if output_file is None:
        output_file = f'amplitude_plot_{os.path.splitext(os.path.basename(input_file))[0]}.png'
    plt.savefig(output_file, dpi=300, bbox_inches='tight')
    plt.close()

def main() -> None:
    """Main function to parse command line arguments and create the plot.
    
    Command line arguments:
        input_file: Path to the input file containing time and amplitude data
        --output, -o: Output file for the plot (default: amplitude_plot_<input>.png)
        --sampling-rate, -s: Sampling rate in Hz (default: extracted from filename)
        --center-frequency, -f: Center frequency (default: extracted from filename)
        --start-time, -t: Start time in format YYYYMMDD_HHMMSS (default: extracted from filename)
        --linear, -l: Display amplitude in linear scale instead of dB
        --fit-gaussian, -g: Fit and plot a Gaussian curve to the data
    """
    parser = argparse.ArgumentParser(description='Plot amplitude vs time from processed I/Q data')
    parser.add_argument('input_file', help='Input file containing time and amplitude data')
    parser.add_argument('--output', '-o', help='Output file for the plot (default: amplitude_plot_<input>.png)')
    parser.add_argument('--sampling-rate', '-s', type=int, help='Sampling rate in Hz (default: extracted from filename)')
    parser.add_argument('--center-frequency', '-f', help='Center frequency (default: extracted from filename)')
    parser.add_argument('--start-time', '-t', help='Start time in format YYYYMMDD_HHMMSS (default: extracted from filename)')
    parser.add_argument('--linear', '-l', action='store_true', help='Display amplitude in linear scale instead of dB')
    parser.add_argument('--fit-gaussian', '-g', action='store_true', help='Fit and plot a Gaussian curve to the data')
    
    args = parser.parse_args()
    
    # Parse start time if provided
    start_time = None
    if args.start_time:
        try:
            start_time = datetime.strptime(args.start_time, "%Y%m%d_%H%M%S")
        except ValueError:
            print("Warning: Invalid start time format. Using time from filename or seconds.")
    
    plot_amplitude_vs_time(
        args.input_file, 
        args.output, 
        args.sampling_rate, 
        args.center_frequency, 
        start_time, 
        args.linear,
        args.fit_gaussian
    )

if __name__ == '__main__':
    main()

